import { z } from 'zod/v4'

import { receivedInvoiceTb } from 'faktorio-db/schema'
import { protectedProc } from '../isAuthorizedMiddleware'
import { trpcContext } from '../trpcContext'
import { eq, desc, and, gte, lt, SQL } from 'drizzle-orm'
import { createInsertSchema } from 'drizzle-zod'
import { TRPCError } from '@trpc/server'
import schema from '../json-schema/receivedInvoicesSchema.json'
import { Schema } from '@google/genai'
import { stringDateSchema, paymentMethodEnum } from './zodSchemas'

// Define Zod schema based on Drizzle schema, making fields optional/required as needed for creation
const receivedInvoiceCreateSchema = createInsertSchema(receivedInvoiceTb)
  .omit({
    id: true, // ID is generated by DB
    user_id: true, // Will be injected from context
    created_at: true, // Defaulted by DB
    updated_at: true, // Set on update
    supplier_contact_id: true // Handle contact linking separately if needed
  })
  .extend({
    status: z
      .enum(['received', 'verified', 'disputed', 'paid'])
      .default('received'),
    tags: z.array(z.string()).optional().default([]),
    items: z
      .array(
        z.object({
          description: z.string().optional(),
          quantity: z.number().optional(),
          unit_price: z.number().optional(),
          unit: z.string().optional(),
          vat_rate: z.number().optional(),
          total_without_vat: z.number().optional(),
          total_with_vat: z.number().optional(),
          accounting_code: z.string().optional()
        })
      )
      .optional()
      .default([]),
    // Make non-null fields explicitly required if not defaulted
    supplier_name: z.string().min(1),
    invoice_number: z.string().min(1),
    issue_date: stringDateSchema,
    due_date: stringDateSchema,
    total_with_vat: z.number(),
    currency: z.string().max(3).min(3).default('CZK'),
    payment_method: paymentMethodEnum.optional(),
    // Add fields not directly in DB schema but needed for UI/logic
    supplier_contact_id: z.string().optional(), // Reference to existing contact
    attachment_data: z.string().optional().nullable() // Base64 encoded image data
  })

// Type for the Gemini OCR processing response
const ocrResponseSchema = z.object({
  supplier_name: z.string().optional(),
  supplier_street: z.string().optional().nullable(),
  supplier_street2: z.string().optional().nullable(),
  supplier_city: z.string().optional().nullable(),
  supplier_zip: z.string().optional().nullable(),
  supplier_country: z.string().optional().nullable(),
  supplier_registration_no: z.string().optional().nullable(),
  supplier_vat_no: z.string().optional().nullable(),
  supplier_email: z.string().optional().nullable(),
  supplier_phone: z.string().optional().nullable(),
  invoice_number: z.string().optional(),
  internal_number: z.string().optional().nullable(),
  variable_symbol: z.string().optional().nullable(),
  expense_category: z.string().optional().nullable(),
  issue_date: stringDateSchema,
  taxable_supply_date: stringDateSchema.optional().nullable(),
  due_date: stringDateSchema,
  receipt_date: stringDateSchema.optional().nullable(),
  payment_date: stringDateSchema.optional().nullable(),
  total_without_vat: z.number().optional().nullable(),
  total_with_vat: z.number().optional(),
  currency: z
    .string()
    .optional()
    .describe('ISO 4217 currency code')
    .default('CZK'),
  exchange_rate: z.number().optional().nullable(),
  vat_base_21: z.number().optional().nullable(),
  vat_21: z.number().optional().nullable(),
  vat_base_15: z.number().optional().nullable(),
  vat_15: z.number().optional().nullable(),
  vat_base_10: z.number().optional().nullable(),
  vat_10: z.number().optional().nullable(),
  vat_base_0: z.number().optional().nullable(),
  reverse_charge: z.boolean().optional().nullable(),
  vat_regime: z.string().optional().nullable(),
  payment_method: z
    .enum(['bank', 'cash', 'card', 'cod', 'crypto', 'other'])
    .optional(),
  bank_account: z.string().optional().nullable(),
  iban: z.string().optional().nullable(),
  swift_bic: z.string().optional().nullable(),
  items: z
    .array(
      z.object({
        description: z.string().optional().nullable(),
        quantity: z.number().optional().nullable(),
        unit_price: z.number().optional().nullable(),
        unit: z.string().optional().nullable(),
        vat_rate: z.number().optional().nullable(),
        total_without_vat: z.number().optional().nullable(),
        total_with_vat: z.number().optional().nullable(),
        accounting_code: z.string().optional().nullable()
      })
    )
    .optional()
    .nullable(),
  status: z.enum(['received', 'verified', 'disputed', 'paid']).optional(),
  line_items_summary: z.string().optional().nullable()
})

export const receivedInvoicesRouter = trpcContext.router({
  list: protectedProc
    .input(
      z.object({
        from: stringDateSchema.optional().nullable(),
        to: stringDateSchema.optional().nullable()
      })
    )
    .query(async ({ ctx, input }) => {
      const conditions: SQL[] = [eq(receivedInvoiceTb.user_id, ctx.user.id)]

      if (input.from) {
        conditions.push(gte(receivedInvoiceTb.taxable_supply_date, input.from))
      }
      if (input.to) {
        conditions.push(lt(receivedInvoiceTb.taxable_supply_date, input.to))
      }

      const invoices = await ctx.db
        .select()
        .from(receivedInvoiceTb)
        .where(and(...conditions))
        .orderBy(desc(receivedInvoiceTb.taxable_supply_date))
      return invoices
    }),

  getById: protectedProc
    .input(z.object({ id: z.string() }))
    .query(async ({ ctx, input }) => {
      const invoice = await ctx.db
        .select()
        .from(receivedInvoiceTb)
        .where(
          and(
            eq(receivedInvoiceTb.id, input.id),
            eq(receivedInvoiceTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!invoice.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invoice not found'
        })
      }

      return invoice[0]
    }),

  create: protectedProc
    .input(receivedInvoiceCreateSchema)
    .mutation(async ({ ctx, input }) => {
      const { attachment_data: _attachment_data, ...invoiceData } = input

      // Basic check for duplicate invoice for the same supplier/number
      const existing = await ctx.db
        .select({ id: receivedInvoiceTb.id })
        .from(receivedInvoiceTb)
        .where(
          and(
            eq(receivedInvoiceTb.user_id, ctx.user.id),
            eq(receivedInvoiceTb.supplier_name, invoiceData.supplier_name),
            eq(receivedInvoiceTb.invoice_number, invoiceData.invoice_number)
          )
        )
        .limit(1)

      if (existing.length > 0) {
        throw new TRPCError({
          code: 'CONFLICT',
          message:
            'An invoice with this number from this supplier already exists.'
        })
      }

      // Save the invoice
      const [newInvoice] = await ctx.db
        .insert(receivedInvoiceTb)

        .values({
          ...invoiceData,
          user_id: ctx.user.id,
          items: invoiceData.items ?? [],
          tags: invoiceData.tags ?? []
        })
        .returning()

      return newInvoice
    }),

  update: protectedProc
    .input(
      receivedInvoiceCreateSchema.extend({
        id: z.string()
      })
    )
    .mutation(async ({ ctx, input }) => {
      const { id, attachment_data: _attachment_data, ...updateData } = input

      // Check if invoice exists and belongs to user
      const existing = await ctx.db
        .select({ id: receivedInvoiceTb.id })
        .from(receivedInvoiceTb)
        .where(
          and(
            eq(receivedInvoiceTb.id, id),
            eq(receivedInvoiceTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!existing.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invoice not found or you do not have permission to edit it.'
        })
      }

      // Update the invoice
      const [updatedInvoice] = await ctx.db
        .update(receivedInvoiceTb)
        .set({
          ...updateData,
          updated_at: new Date().toISOString()
        })
        .where(eq(receivedInvoiceTb.id, id))
        .returning()

      return updatedInvoice
    }),

  delete: protectedProc
    .input(z.object({ id: z.string() }))
    .mutation(async ({ ctx, input }) => {
      // Check if invoice exists and belongs to user
      const existing = await ctx.db
        .select({ id: receivedInvoiceTb.id })
        .from(receivedInvoiceTb)
        .where(
          and(
            eq(receivedInvoiceTb.id, input.id),
            eq(receivedInvoiceTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!existing.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message:
            'Invoice not found or you do not have permission to delete it.'
        })
      }

      // Delete the invoice
      await ctx.db
        .delete(receivedInvoiceTb)
        .where(eq(receivedInvoiceTb.id, input.id))

      return { success: true }
    }),

  // OCR an invoice with Gemini API
  extractInvoiceData: protectedProc
    .input(
      z.object({
        mimeType: z.string(),
        imageData: z.string() // Base64 encoded image data
      })
    )
    .mutation(async ({ ctx, input }) => {
      try {
        if (!schema) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to load schema for OCR processing'
          })
        }

        // Clean the image data (remove data:image/jpeg;base64, prefix if present)
        const base64Data = input.imageData.replace(
          /^data:image\/\w+;base64,/,
          ''
        )
        // yes it's weird that we need to put the json schema in the prompt
        const prompt = `Extract invoice data from this image. Respond with valid JSON according to the following schema:
\`\`\`json
${JSON.stringify(schema)}
\`\`\`

Return ONLY the JSON object, nothing else. If you cannot extract some fields, leave them as null.
For dates, use the format YYYY-MM-DD. If you can't determine the exact date, make your best guess.
If the document is a credit note (dobropis), make sure all taxable amounts, VAT amounts, and totals are negative values.
The text that is partially unreadable, leave the "?" for each unreadable character.`

        // Get the model

        // TODO use https://googleapis.github.io/js-genai/main/classes/files.Files.html to allow uploading files bigger than 7MB

        const makeGeminiRequest = (model: string) =>
          ctx.googleGenAI.models.generateContent({
            model,
            contents: [
              {
                parts: [
                  { text: prompt },
                  {
                    inlineData: {
                      mimeType: input.mimeType,
                      data: base64Data
                    }
                  }
                ]
              }
            ],
            config: {
              systemInstruction: `You are a data extraction assistant. Your main objective is to extract invoice data from an image of a czech invoice. Most likely the invoice is in CZK currency, but on the invoice it is often represented as Kč. The format we want for currency field is ISO 4217.`,
              // @ts-expect-error types are not correct
              responseSchema: schema as Schema,
              temperature: 0.2,
              thinkingConfig: {
                includeThoughts: false,
                thinkingBudget: 0
              }
            }
          })

        let result
        try {
          result = await makeGeminiRequest('gemini-2.5-flash')
        } catch (err) {
          const message = (err as Error)?.message ?? ''
          const status =
            (err as any)?.status ??
            (err as any)?.response?.status ??
            (err as any)?.code
          const isOverloaded =
            status === 503 ||
            /UNAVAILABLE/i.test(String(message)) ||
            /model is overloaded/i.test(String(message))
          if (isOverloaded) {
            result = await makeGeminiRequest('gemini-2.5-flash-lite')
          } else {
            throw err
          }
        }

        const textContent = result.text ?? ''

        // Try to find JSON object in the response
        let extractedData
        try {
          const jsonMatch = textContent.match(/\{[\s\S]*\}/)
          if (jsonMatch) {
            extractedData = JSON.parse(jsonMatch[0])
          } else {
            throw new Error('No valid JSON found in response')
          }
        } catch (error) {
          console.error('Error parsing Gemini response:', error)
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to parse OCR results'
          })
        }

        console.log('extractedData for invoice:', extractedData)
        // Validate data against our schema
        try {
          const validatedData = ocrResponseSchema.parse(extractedData)
          return validatedData
        } catch (error) {
          console.error('Validation error:', error)
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'OCR results did not match expected format'
          })
        }
      } catch (error) {
        console.error('OCR processing error:', error)
        if (error instanceof TRPCError) {
          throw error
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to process image: ' + (error as Error).message
        })
      }
    })
})

export type ReceivedInvoicesRouter = typeof receivedInvoicesRouter
