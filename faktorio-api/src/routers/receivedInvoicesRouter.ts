import { z } from 'zod'

import { receivedInvoiceTb, contactTb } from '../schema'
import { protectedProc } from '../isAuthorizedMiddleware'
import { trpcContext } from '../trpcContext'
import { eq, desc, and, gte, lt, SQL } from 'drizzle-orm'
import { createInsertSchema } from 'drizzle-zod'
import { TRPCError } from '@trpc/server'
import schema from '../json-schema/receivedInvoicesSchema.json'
import { GoogleGenAI, Schema } from '@google/genai'
import { stringDateSchema, paymentMethodEnum } from './zodSchemas'

// Define Zod schema based on Drizzle schema, making fields optional/required as needed for creation
// We will refine this based on the frontend form later
const receivedInvoiceCreateSchema = createInsertSchema(receivedInvoiceTb, {
  id: z.undefined(), // ID is generated by DB
  user_id: z.undefined(), // Will be injected from context
  created_at: z.undefined(), // Defaulted by DB
  updated_at: z.undefined(), // Set on update
  status: z
    .enum(['received', 'verified', 'disputed', 'paid'])
    .default('received'),
  tags: z.array(z.string()).optional().nullable().default([]),
  items: z
    .array(
      z.object({
        description: z.string().optional().nullable(),
        quantity: z.number().optional().nullable(),
        unit_price: z.number().optional().nullable(),
        unit: z.string().optional().nullable(),
        vat_rate: z.number().optional().nullable(),
        total_without_vat: z.number().optional().nullable(),
        total_with_vat: z.number().optional().nullable(),
        accounting_code: z.string().optional().nullable()
      })
    )
    .optional()
    .nullable()
    .default([]),

  // Make non-null fields explicitly required if not defaulted
  supplier_name: z.string().min(1),
  invoice_number: z.string().min(1),
  issue_date: stringDateSchema,
  due_date: stringDateSchema,
  total_with_vat: z.number(),
  currency: z.string().max(3).min(3).default('CZK')
})
  .omit({
    // Fields to be excluded or handled differently
    supplier_contact_id: true // Handle contact linking separately if needed
  })
  .extend({
    // Add fields not directly in DB schema but needed for UI/logic
    supplier_contact_id: z.string().optional().nullable(), // Reference to existing contact
    attachment_data: z.string().optional().nullable() // Base64 encoded image data
  })

// Type for the Gemini OCR processing response
const ocrResponseSchema = z.object({
  supplier_name: z.string().optional(),
  supplier_street: z.string().optional().nullable(),
  supplier_street2: z.string().optional().nullable(),
  supplier_city: z.string().optional().nullable(),
  supplier_zip: z.string().optional().nullable(),
  supplier_country: z.string().optional().nullable(),
  supplier_registration_no: z.string().optional().nullable(),
  supplier_vat_no: z.string().optional().nullable(),
  supplier_email: z.string().optional().nullable(),
  supplier_phone: z.string().optional().nullable(),
  invoice_number: z.string().optional(),
  internal_number: z.string().optional().nullable(),
  variable_symbol: z.string().optional().nullable(),
  expense_category: z.string().optional().nullable(),
  issue_date: stringDateSchema,
  taxable_supply_date: stringDateSchema.optional().nullable(),
  due_date: stringDateSchema,
  receipt_date: stringDateSchema.optional().nullable(),
  payment_date: stringDateSchema.optional().nullable(),
  total_without_vat: z.number().optional().nullable(),
  total_with_vat: z.number().optional(),
  currency: z
    .string()
    .optional()
    .describe('ISO 4217 currency code')
    .default('CZK'),
  exchange_rate: z.number().optional().nullable(),
  vat_base_21: z.number().optional().nullable(),
  vat_21: z.number().optional().nullable(),
  vat_base_15: z.number().optional().nullable(),
  vat_15: z.number().optional().nullable(),
  vat_base_10: z.number().optional().nullable(),
  vat_10: z.number().optional().nullable(),
  vat_base_0: z.number().optional().nullable(),
  reverse_charge: z.boolean().optional().nullable(),
  vat_regime: z.string().optional().nullable(),
  payment_method: paymentMethodEnum,
  bank_account: z.string().optional().nullable(),
  iban: z.string().optional().nullable(),
  swift_bic: z.string().optional().nullable(),
  items: z
    .array(
      z.object({
        description: z.string().optional().nullable(),
        quantity: z.number().optional().nullable(),
        unit_price: z.number().optional().nullable(),
        unit: z.string().optional().nullable(),
        vat_rate: z.number().optional().nullable(),
        total_without_vat: z.number().optional().nullable(),
        total_with_vat: z.number().optional().nullable(),
        accounting_code: z.string().optional().nullable()
      })
    )
    .optional()
    .nullable(),
  status: z.enum(['received', 'verified', 'disputed', 'paid']).optional(),
  line_items_summary: z.string().optional().nullable()
})

export const receivedInvoicesRouter = trpcContext.router({
  list: protectedProc
    .input(
      z.object({
        from: stringDateSchema.optional().nullable(),
        to: stringDateSchema.optional().nullable()
      })
    )
    .query(async ({ ctx, input }) => {
      const conditions: SQL[] = [eq(receivedInvoiceTb.user_id, ctx.user.id)]

      if (input.from) {
        conditions.push(gte(receivedInvoiceTb.taxable_supply_date, input.from))
      }
      if (input.to) {
        conditions.push(lt(receivedInvoiceTb.taxable_supply_date, input.to))
      }

      const invoices = await ctx.db
        .select()
        .from(receivedInvoiceTb)
        .where(and(...conditions))
        .orderBy(desc(receivedInvoiceTb.taxable_supply_date))
      return invoices
    }),

  getById: protectedProc
    .input(z.object({ id: z.string() }))
    .query(async ({ ctx, input }) => {
      const invoice = await ctx.db
        .select()
        .from(receivedInvoiceTb)
        .where(
          and(
            eq(receivedInvoiceTb.id, input.id),
            eq(receivedInvoiceTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!invoice.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invoice not found'
        })
      }

      return invoice[0]
    }),

  create: protectedProc
    .input(receivedInvoiceCreateSchema)
    .mutation(async ({ ctx, input }) => {
      const { attachment_data, ...invoiceData } = input

      // Basic check for duplicate invoice for the same supplier/number
      const existing = await ctx.db
        .select({ id: receivedInvoiceTb.id })
        .from(receivedInvoiceTb)
        .where(
          and(
            eq(receivedInvoiceTb.user_id, ctx.user.id),
            eq(receivedInvoiceTb.supplier_name, invoiceData.supplier_name),
            eq(receivedInvoiceTb.invoice_number, invoiceData.invoice_number)
          )
        )
        .limit(1)

      if (existing.length > 0) {
        throw new TRPCError({
          code: 'CONFLICT',
          message:
            'An invoice with this number from this supplier already exists.'
        })
      }

      // Save the invoice
      const [newInvoice] = await ctx.db
        .insert(receivedInvoiceTb)
        // @ts-expect-error - TODO fix this
        .values({
          ...invoiceData,
          user_id: ctx.user.id,
          items: invoiceData.items ?? [],
          tags: invoiceData.tags ?? []
        })
        .returning()

      return newInvoice
    }),

  update: protectedProc
    .input(
      receivedInvoiceCreateSchema.extend({
        id: z.string()
      })
    )
    .mutation(async ({ ctx, input }) => {
      const { id, attachment_data, ...updateData } = input

      // Check if invoice exists and belongs to user
      const existing = await ctx.db
        .select({ id: receivedInvoiceTb.id })
        .from(receivedInvoiceTb)
        .where(
          and(
            eq(receivedInvoiceTb.id, id),
            eq(receivedInvoiceTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!existing.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Invoice not found or you do not have permission to edit it.'
        })
      }

      // Update the invoice
      const [updatedInvoice] = await ctx.db
        .update(receivedInvoiceTb)
        // @ts-expect-error - TODO fix this
        .set({
          ...updateData,
          updated_at: new Date().toISOString()
        })
        .where(eq(receivedInvoiceTb.id, id))
        .returning()

      return updatedInvoice
    }),

  delete: protectedProc
    .input(z.object({ id: z.string() }))
    .mutation(async ({ ctx, input }) => {
      // Check if invoice exists and belongs to user
      const existing = await ctx.db
        .select({ id: receivedInvoiceTb.id })
        .from(receivedInvoiceTb)
        .where(
          and(
            eq(receivedInvoiceTb.id, input.id),
            eq(receivedInvoiceTb.user_id, ctx.user.id)
          )
        )
        .limit(1)

      if (!existing.length) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message:
            'Invoice not found or you do not have permission to delete it.'
        })
      }

      // Delete the invoice
      await ctx.db
        .delete(receivedInvoiceTb)
        .where(eq(receivedInvoiceTb.id, input.id))

      return { success: true }
    }),

  // OCR an invoice with Gemini API
  extractInvoiceData: protectedProc
    .input(
      z.object({
        mimeType: z.string(),
        imageData: z.string() // Base64 encoded image data
      })
    )
    .mutation(async ({ ctx, input }) => {
      try {
        if (!schema) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to load schema for OCR processing'
          })
        }

        // Clean the image data (remove data:image/jpeg;base64, prefix if present)
        const base64Data = input.imageData.replace(
          /^data:image\/\w+;base64,/,
          ''
        )
        // yes it's weird that we need to put the json schema in the prompt
        const prompt = `Extract invoice data from this image. Respond with valid JSON according to the following schema:
\`\`\`json
${JSON.stringify(schema)}
\`\`\`

Return ONLY the JSON object, nothing else. If you cannot extract some fields, leave them as null.
For dates, use the format YYYY-MM-DD. If you can't determine the exact date, make your best guess.
The text that is partially unreadable, leave the "?" for each unreadable character.`

        // Get the model

        // TODO use https://googleapis.github.io/js-genai/main/classes/files.Files.html to allow uploading files bigger than 7MB

        // Generate content with the vision model
        const result = await ctx.googleGenAI.models.generateContent({
          model: 'gemini-2.5-flash-preview-04-17',
          contents: [
            {
              parts: [
                { text: prompt },
                {
                  inlineData: {
                    mimeType: input.mimeType,
                    data: base64Data
                  }
                }
              ]
            }
          ],
          config: {
            systemInstruction: `You are a data extraction assistant. Your main objective is to extract invoice data from images of czech invoices. Most invoices are in CZK currency, but on the invoice it is often represented as Kƒç. The format we want for currency is ISO 4217.`,
            // @ts-expect-error types are not correct
            responseSchema: schema as Schema,
            temperature: 0.2,
            thinkingConfig: {
              includeThoughts: false,
              thinkingBudget: 0
            }
          }
        })

        const textContent = result.text ?? ''

        // Try to find JSON object in the response
        let extractedData
        try {
          const jsonMatch = textContent.match(/\{[\s\S]*\}/)
          if (jsonMatch) {
            extractedData = JSON.parse(jsonMatch[0])
          } else {
            throw new Error('No valid JSON found in response')
          }
        } catch (error) {
          console.error('Error parsing Gemini response:', error)
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to parse OCR results'
          })
        }

        console.log('extractedData for invoice:', extractedData)
        // Validate data against our schema
        try {
          const validatedData = ocrResponseSchema.parse(extractedData)
          return validatedData
        } catch (error) {
          console.error('Validation error:', error)
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'OCR results did not match expected format'
          })
        }
      } catch (error) {
        console.error('OCR processing error:', error)
        if (error instanceof TRPCError) {
          throw error
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to process image: ' + (error as Error).message
        })
      }
    })
})

export type ReceivedInvoicesRouter = typeof receivedInvoicesRouter
